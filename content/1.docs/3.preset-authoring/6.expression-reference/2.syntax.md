---
title: Syntax
description: General syntax of the expression code.
---

## General Syntax

The expression language only knows a few syntactic features:

- Numbers, with or without decimals. Can also contain an _integer_ base-10 exponent using the `e[+-]n` notation.
- [Variables](variables) to hold a single number, both user-defined and predefined.
- [Special constants](undocumented-features#constants) starting with `$` (
  see [Undocumented Features](undocumented-features)).
- A single expression, separated from other expressions in the same list via semicolons (`;`), with the last semicolon
  being optional.
- Calls to [built-in functions](functions) in the form `func(arg1, arg2, ...)`.
- Mathematical, assignment and other [operators](operators).
- Subscript access `[]` for [megabuf/gmegabuf access](megabuf).
- Parentheses (`()`) to group statements and override precedence.
- In-line comments starting with `//` until the end of the current line
- Multi-line comments starting with `/*` and ended with `*/`.

## Return Types

Expressions can return either a numeric value or a reference to a variable or memory location. What is actually returned
is determined by the function or operator that is executed last. If the expression only consists or a single token, then
the following applies:

- If the expression token is a constant number (`1.0;`), the number is returned by value.
- If the expression token is a variable name (`x;`), a reference to the variable is returned.

For most functions, the return type doesn't matter. If it's a reference, the value pointed to by the reference is used.
References only behave differently when used on the left side of assignments or in the first argument of the `assign()`
function. In this case, the variable or (g)megabuf location the reference points to is assigned a new value.

Due to this, it is perfectly valid to assign a value to a constant (such as `1.0 = 2.0;`), as the constant is returned
as a value, which is then simply replaced with a new one in the result register, leaving the original constant
untouched.

## Expression Result

Every expression returns its outermost result, as a value or reference as described above. When writing multiple
expressions (separated by semicolon) in a list, the result of the _rightmost_ (or last) expression is returned. The
results of previous expressions are discarded.

In general, each expression will be in the form `var = expression;`, assigning a value to the given variable (or
megabuf index). Expressions will also always return a value, so when used as function arguments, this value will be
used. For example, all the following statements will call the `sin()` function with the argument `4`:

```
x = sin(val = 2 * 2);
y = sin(2 + 2);
z = sin(4.0);
```

## Variable and Function Names, Limits

Variable and function names are generally case-insensitive, making `variable` equivalent to `vArIaBlE`.

Any text in expressions - starting with either a letter from a to z or an underscore, followed by more of these
characters and also numbers from 0 to 9 - is first checked to be a built-in function. If it is not a function, the
parser will interpret it as a variable.

Functions always need to be followed by parentheses (`sin(expr)`), while variables must not.

Milkdrop imposes a 16-character limit on variable names. projectm-eval does not have a hard limit, but it's advisable to
not use more than 16 characters for Milkdrop compatibility.

Milkdrop also has a limit of 64 user-defined variables, which also isn't applied by projectM.

## Numbers

All numbers are converted into floating-point numbers internally, even if written as integers.

Basic numerical/decimal constants can be defined in the code in the following formats:

### Integer Values

Any number without a decimal point or exponent, e.g. `1`.

Integers are internally first converted to a 32-bit signed integer value, then to a floating-point number. This means
that using any number without a decimal point will end up being between `-2147483648` and `2147483647`.

### Decimal Values

Any number containing a decimal point (`.`) ar an exponent `e` will be directly converted to a floating-point number.

Valid examples are:

- `1.234`
- `1.` (equals `1.000`)
- `.234` (equals `0.234`)
- `1.234E5` (equals `123400`)
- `1.234e-5` (equals `0.00001234`)

## Using Parentheses

Parentheses can be used to specify a specific order in which operations are executed. Expressions inside parentheses are
always evaluated, and the result of the evaluation is then used to evaluate any outside expression.

Inside parentheses, using expression lists is also valid. The result is, as described above, the value of the last
expression in the list. For example, the following expression will use `5` as the return value:

```
x = a * (b + c; d + e; 2 + 3);
```

The first two operations will do nothing, as they don't set a variable or memory value and the results are discarded.

## Comments

For more complex calculations, it might be a good idea to leave some comments in the expressions to describe what's done
in a specific line or block. Comments can also be useful to quickly disable a line or block of code to try out things
when writing a preset.

Comments can be used as end-of-line or block variants:

```
x = sin(5); // This comment is only valid until the line ends
y = sin($PI * .5); /* This comment
spans
multiple
lines and the following expression is executed: */ z = 5;
```

Comments can appear inside any expression, but _not_ within a variable, function name, number or other constant.
Writing `x = var/*comment*/iable;` is invalid (but `x = sin/*comment*/(variable);` is).
