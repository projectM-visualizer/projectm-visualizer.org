---
title: Using Expressions
description: Writing math expressions to control preset effect rendering.
---

While some effects already produce a certain amount of movement and reactivity, the real magic in Milkdrop presets
happens in the expression code.

**Important:** Expressions are not shaders! They use a different language and solely run on the CPU.

## Features

These expressions are written in a simple scripting language which is similar to what scientific programmable
calculators accept as inputs. It is not a fully-featured scripting language, but powerful enough for basically any use
case. It supports the following language features:

- A single data type: floating-point numbers.
- User-defined variables with names up to 16 characters.
- The usual set of operators for math, logic and assignment.
- A good number of built-in math functions.
- Several control-structure functions for implementing conditionals and simple loops.

The expressions do _not_ support custom functions, writing reusable code blocks and defining data structures.

## Performance

Expressions generally perform very well, at near-native speeds of compiled code.

The original Milkdrop and most derivatives use
the original ["ns-eel2"](https://github.com/projectM-visualizer/milkdrop2/tree/master/src/ns-eel2) (short for "NullSoft
Expression Evaluation Library 2") implementation. It uses handwritten win32 assembly code - while there are ports of the
assembly to x86_64 and PPC architectures, it generally only compiles and runs on the Windows 32-bit platform.

projectM, being a cross-platform, cross-architecture implementation, uses a newly written parser
called ["projectm-eval"](https://github.com/projectM-visualizer/projectm-eval), which is written in C and thus compiles
on basically any platform supporting floating-point math and the C99 standard library.

### Milkdrop / ns-eel2

In the original Milkdrop, code is parsed and the resulting structure is then built from blocks of pre-compiled Intel 486
assembly instructions.

This makes the code basically as performant as natively- or JIT-compiled code. The downside is that the assembly
instructions are quite old and there are probably more performant variants of doing things in modern CPUs, which can't
be used since the compiler cannot optimize the assembly code.

### projectM / projectm-eval

projectM's custom approach builds a simple tree structure from the code, then recursively calls the functions
implementing the language features to execute the code.

Since compilers can optimize the implementation to run faster on modern CPUs and the code has been designed with the
lowest possible runtime overhead (e.g. not using return values, omitting stack frame pointers) in mind, the average
performance should be nearly identical to ns-eel2.
