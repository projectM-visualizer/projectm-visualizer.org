---
title: Memory Buffers
description: Large memory buffers to store values.
---

Since Milkdrop 2, a new feature to store values called "megabuf" was added. It adds several memory buffers which can be
used in all expressions, with each buffer being able to store up to 8,388,608 numbers.

Each execution context in Milkdrop has its own memory buffer, plus an additional one called "gmegabuf" that is globally
available across all code blocks. Execution contexts are generally tied to a specific effect. This is a list of all
10 contexts and which ones share a megabuf, with one context per line:

- `per_frame_init_` and `per_frame_`
- `per_pixel_`
- `wave_1_init`, `wave_1_per_frame` and `wave_1_per_point`
- `wave_2_init`, `wave_2_per_frame` and `wave_2_per_point`
- `wave_3_init`, `wave_3_per_frame` and `wave_3_per_point`
- `wave_4_init`, `wave_4_per_frame` and `wave_4_per_point`
- `shape_1_init` and `shape_1_per_frame`
- `shape_2_init` and `shape_2_per_frame`
- `shape_3_init` and `shape_3_per_frame`
- `shape_4_init` and `shape_4_per_frame`

This means there are 11 separate buffers per preset, allowing to store 92,274,688 different values. Using all slots
would require 704 MB of RAM (numbers are stored as 64-bit/8-byte double-precision floats internally).

The global memory buffer can be used to circumvent the way of how values are passed using `qNN` and `tN` variables,
similar to how `regNN` variables work, but having a larger capacity. Since this buffer is also not touched between
frames, it can be used to carry values from an effect late in a frame to another effect drawn in the next frame, like
custom waveform/spectrum values to be used in custom shapes. While this will have a single frame of lag, it opens up a
few additional possibilities such as drawing spectrum data using custom shapes or the warp grid.

Warp and composite shaders do not have access to these buffers, as they run on the GPU.

## Buffer Allocation

To reduce the number of memory allocations at runtime, values are not individually allocated in system memory. Rather,
Milkdrop and projectM allocate up to 128 blocks of 65,536 values per buffer.

Each time a value index is accessed, it is checked whether the block this index is stored is already allocated. If it
is, the existing block will be accessed. If not, a new memory block is allocated and filled with zeroes.

### Memory Usage Warning

This in turn means if a preset accesses the first index of each block once, _all_ memory block would be allocated. In
theory, the original ns-eel2 interpreter in Milkdrop supports setting a memory limit, but this feature is not used and
thus there is no memory cap except the size of all buffers combined.

When writing presets, it's highly recommended to not spread memory indices too far, e.g. trying to keep them within one
or two memory blocks if possible. In practice, most presets will probably only make use of the global buffer, ignoring
the context-specific ones altogether. On modern PCs, a few MB of RAM usage won't have a big impact anyway.

## Accessing Memory Buffers

The global and context-specific memory buffers can be accessed with different methods.

### megabuf()

The `megabuf()` functions returns a reference to a single value in the memory buffer of the current execution context.
The return value is a reference, and thus can be both read and assigned to:

```
x = megabuf(1000);
megabuf(1001) = x + 1;
```

### gmegabuf()

The `gmegabuf()` functions returns a reference to a single value in the preset-global memory buffer. The return value is
a reference, and thus can be both read and assigned to:

```
x = gmegabuf(1000);
gmegabuf(1001) = x + 1;
```

### Subscript Operator

The subscript operator or "array access operator" has a slightly different meaning than in other programming languages.
The Milkdrop expression syntax only knows a single data type, individual numbers, so there are no arrays.

If any index value is not an integer, it is _rounded_ to the nearest integer after calculating the final index (e.g.
adding index and offset first, then rounding).

The subscript operator is instead used to address memory locations in megabuf and gmegabuf. There are three possible
syntax variants:

#### Global Memory Access

Accessing the gmegabuf is possible by using the special keyword `gmem`, followed by an index in the subscript brackets.
The following statement sets gmegabuf location 10.000 to the current value of `x`:

```
gmem[10000] = x;
```

Any memory index from 0 to 8.388.607 (= 128 * 65536) can be addressed.

#### Local Memory Access

Accessing the current context memory buffer (megabuf) can be done by writing the index before a set of empty brackets.
The following example is analogous to the above, but it sets index 10.000 of the local memory instead:

```
10000[] = x;
```

#### Local Memory Access with Offset

An optional offset can be provided in the brackets, which is simply added to the index on the outside. The following
example will set memory index 10.123 to the value of `x`:

```
10000[123] = x;
```

Both index and offset values can of course be calculated with expressions. So the following expression is valid:

```
if(x > 5,5000,1000)[(sin(y) + 1 * .5) * 1000] = z;
```

## Initializing a Range

**Note:** This works only on context-specific memory buffers, _not_ gmegabuf!

If a large portion of a context-specific memory buffer needs to be initialized with a specific, single value, the
`memset` function can be used instead of `loop` and iterating over all indices. The following lines are equivalent, with
the second one being more performant - both set 1000 values to 1.123, starting at index 4000:

```
idx=0; loop(1000, 4000[idx] = 1.123; idx += 1); 
memset(4000, 1.123, 1000);
```

## Copying Ranges

**Note:** This works only on context-specific memory buffers, _not_ gmegabuf! There is no way of either copying ranges
within gmegabuf or between gmegabuf and a context megabuf.

In the case a large, continuous portion of values need to be copied, the `loop` function in expression code is way
slower than using [the `memcpy`function](functions#memcpydest-src-count). This function takes a destination index, a
source index and a count as arguments and then copies `count` values starting at the source index to the destination
index.

To copy 1000 values from index 2000 to 4000, both of the following lines would do this, with the second one being
way more performant:

```
idx=0; loop(1000, 4000[idx] = 2000[idx]; idx += 1); 
memcpy(4000, 2000, 1000);
```

## Freeing Memory

While the expression language defines a function [`freembuf`](functions#freembufindex), it doesn't actually do anything
in Milkdrop or projectM. Once memory has been allocated, it'll stay that way until either the preset is unloaded
(context-specific buffers and gmegabuf in projectM) or Milkdrop is closed (gmegabuf in Milkdrop).

## Cross-Preset Sharing

In the original Milkdrop and most derivatives, the global memory buffer is shared across presets being blended. While
rare, this can occasionally break presets making heavy use of gmegabuf, as the newly loaded preset may use the same
buffer indices as the previous one.

projectM does use one gmegabuf instance per preset, so each preset is fully independent regarding gmegabuf use.
